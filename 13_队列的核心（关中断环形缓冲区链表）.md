# 13_队列的核心（关中断/环形缓冲区/链表）



## 队列的休眠唤醒内部机制

假设任务 A 写队列，任务 B 读这个队列。

当任务 A 写队列时，写队列函数 `xSendQueue` 内部：

- 关中断，写数据
- 唤醒等待该队列的任务

问题在于：**写队列函数如何知道要唤醒谁？**

所谓队列其实是一个结构体，里面会有某个链表（假设可以称之为 `Queue.list1`）。

当任务 B 尝试读队列时被休眠，任务 B 不仅会从 ReadyList 中被放入某个 DelayList，还会被读队列函数记录到链表 `Queue.list1` 中。

而任务 A 写队列的时候，就会去链表 `Queue.list1` 中找到任务 B 并唤醒它。

```c
xSendQueue()
{
    // 关中断
    
    // 写数据
    
    // 链表操作
    
    // 恢复中断
}
```



## 队列的数据存储

队列中，数据本身是通过环形缓冲区来存储的。

所谓的 “环形” 并不存在，只是通过重置缓冲区的读/写位置来实现抽象的 “环形”。

环形缓冲区的设计关键在于：如何区分缓冲区空和满的判断条件？

- `Read` 位置追上 `Write` 位置视为空
- `Write` 位置在 `Read` 位置后面并相隔 1 个下标视为满