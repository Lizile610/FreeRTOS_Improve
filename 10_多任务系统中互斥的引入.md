# 10_多任务系统中互斥的引入



## 为什么要实现互斥？

通过一个例子来解释：

假设 `A_func` 和 `B_func` 两个函数使用一个全局变量 `a` 来通信，`A_func` 和 `B_func` 中都有 `a++`

```c
int a = 0;

void A_func (void)
{
    a++;
    // 其他操作
}

void B_func (void)
{
    a++;
    // 其他操作
}

int main ()
{
    xTaskCreate(A_func, ...);  // 创建任务 A
    xTaskCreate(B_func, ...);  // 创建任务 B
    
    // 启动调度器
}
```

实际上，无论是 `A_func` 还是 `B_func` 进行 `a++` 操作，在寄存器和内存之间都有这样一个过程：

```c
// 假设使用 R0 寄存器来操作变量 a

R0 <= [a]      // 1.从 a 的地址读数值到 R0
R0 = R0 + 1    // 2.数值增加
R0 => [a]      // 3.将 R0 的值写回 a 的地址
```

假设任务调度器启动后，任务 A 先进行 `a++` 操作，只执行了上述过程中的第 1 步，就被切换为任务 B 运行。

在切换之前，任务 A 要先保存现场，则**任务 A 的栈里，`R0` 的值为 0**。

任务 B 开始运行时，全局变量 `a` 的值仍为 0 假设任务 B 完整地执行了上述过程，将全局变量 `a` 的值更改为 1，并切换为任务 A 运行。

此时任务 A 恢复现场（其中 `R0` 中的值为 0），继续执行上述过程剩下的步骤，会把数值 1 写回 `a` 的地址，最终全局变量 `a` 的值为 1。

最终，任务 A 和任务 B 都执行了一次 `a++` 操作，变量 `a` 却只增加了 1，这就是**因为任务 A 和任务 B 没有互斥地访问变量 `a`**。