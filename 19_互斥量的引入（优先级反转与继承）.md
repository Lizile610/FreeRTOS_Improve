# 19_互斥量的引入（优先级反转与继承）



## 为什么要引入互斥量

已知信号量有两种类型：

- 计数型：

  可以将信号量的最大计数值设置为 `Max`，那么信号量的计数值就有 `Max + 1` 种

- 二进制型：

  信号量的计数值只有 0 或 1

互斥量和二进制信号量类似，计数值也只有 0 或 1，那么为什么还要引入互斥量？

因为互斥量比二进制信号量多了一个机制：**优先级继承机制**



## 优先级继承

首先，优先级继承是为了解决**优先级反转**的问题。

### 什么是优先级反转？

假设有三个不同优先级的任务和一个二进制信号量，最高优先级的任务称为 “老大”，次优先级的任务称为 “老二”， 最低优先就的任务称为 “老三”。

某一时刻 “老三” 运行，获取了二进制信号量，还没来得及释放信号量，这时 “老二” 出来抢占运行了。

又过了一会儿，“老大” 出来抢占运行，并且尝试获取信号量，但是失败了，因为信号量在 “老三” 手里，于是阻塞。

这时候 “老二” 又出来运行，“老三” 却因为优先级比 “老二” 低，永远没有机会运行（除非 “老二” 因为某些操作而放弃运行，但这种机会可能很渺茫），信号量永远无法得到释放。

于是就出现了 “老大” 被 “老二” 抢占了的情况，这就是所谓的**优先级反转**。

### 什么是优先级继承？

还是这三个任务，但是这次 “老三” 和 “老大” 不用二进制信号量了，改为用互斥量。

一开始依然是 “老三” 运行，获得了互斥量，还没来得及释放互斥量，又再次被 “老二” 抢占运行了。

一会儿 “老大” 又出来抢占运行，尝试获取互斥量，又失败了，“老三” 还没有释放互斥量。

但是没关系，老大发现自己拿不到互斥量，就让 “老三” 继承了自己的优先级，让 “老三” 赶快做完手上的事情，然后把互斥量放出来。

这时候 “老三” 就成了临时的老大，优先级比 “老二” 还高。真正的 “老大” 因为拿不到互斥量而阻塞了，而 “老三” 就出来抢占运行，最后把互斥量释放了出来。除了释放互斥量，“老三” 还要识趣地把自己的优先级恢复成原来那样，又变回最低优先级。

而 “老大” 马上就出来抢占运行，拿走互斥量，继续运行下去。

于是就不会再出现 “老二” 抢占 “老大” 运行机会的情况，这就是互斥量提供的优先级继承机制。	

### 关于 “继承”

优先级继承只会发生在需要提升优先级的情况。

比如说，互斥量在任务 A 手里，任务 B 和任务 C 都想获得这个互斥量。

而任务 B 的优先级比任务 A 高，任务 C 的优先级比任务 A 低，那么只有任务 B 能让任务 A 继承自己的优先级（提升了任务 A 的优先级），任务 C 无法让任务 A 继承自己的优先级（这样做会降低任务 A 的优先级）。

也就是说，优先级继承只会让持有互斥量的任务临时提高优先级，不会让其降低优先级。