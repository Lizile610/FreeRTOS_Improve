# 24_软件定时器（timer）理论介绍



## 什么是软件定时器

Tick 中断就是个硬件定时器，每隔一个 Tick 触发一次定时器中断，而软件定时器就是基于硬件定时器实现的一种定时器。

使用软件定时器（SoftTimer）时，会构造一个结构体，内部结构大致如下：

```c
struct {
    // 函数指针：时间到了要做什么？
    
    // timeout：超时时间
    
    // 属性：周期性？一次性？
}
```

定时器里的超时时间是这样判断的：

- 假设在 `xTickCount = t1` 时创建了一个 timeout 为 100 的定时器，那么 `expire_time = t1 + timeout`，即定时器将会在 `xTickCount = t101` 时触发，然后跳转到函数指针指向的函数



## 为什么说软件定时器是基于硬件定时器的？

首先看看某些操作系统（如 RTT）是如何设计软件定时器的：

- 实际开发过程中，可能不止用到一个软件定时器，因此会有一个 `SoftTimerList` 链表，里面存放有一个个软件定时器的结构体，并且根据其中的到期时间 `expire_time` 来对这些结构体排序。

- 当 `SysTick`（系统 Tick 中断）发生时，会在中断处理函数中处理 `SoftTimerList` 链表，看看里面有没有软件定时器到期，如果有就调用该软件定时器里的函数指针。

FreeRTOS 则认为，上述设计方式是不安全的，因为软件定时器里调用的函数需要花费的时间是不确定的，FreeRTOS 不允许这种情况。

FreeRTOS 是这样处理软件定时器的：

- 当 `SysTick` 发生，如果有软件定时器到期，中断处理函数会将其写入一个定时器队列（`TimerQueue`），而一个叫做 `TimerTask` 的任务会读这个 `TimerQueue`
- 如果 `TimerTask` 读到了 `TimerQueue`，就被唤醒，然后处理相应的软件定时器：
  - 可能是启动/停止这个软件定时器
  - 可能是修改这个软件定时器的超时时间、属性等
  - 可能是调用这个软件定时器里的函数

FreeRTOS 这种软件定时器机制效率会低一些，但是其设计思想是尽量避免在中断里直接调用时间不确定的函数，很多其它的操作系统则是直接在硬件定时器中断里处理。

而 FreeRTOS 这种软件定时器的处理方式与在中断里设置事件组的 bits 事件类似，都是通过委托另一个任务来执行具体的操作。